/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BaseChug
 */
export interface BaseChug {
    /**
     * 
     * @type {Member}
     * @memberof BaseChug
     */
    'member': Member;
    /**
     * 
     * @type {number}
     * @memberof BaseChug
     */
    'time': number;
}
/**
 * 
 * @export
 * @interface Card
 */
export interface Card {
    /**
     * 
     * @type {number}
     * @memberof Card
     */
    'member_id': number;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'card_uid': string;
}
/**
 * 
 * @export
 * @interface CreateCard
 */
export interface CreateCard {
    /**
     * 
     * @type {number}
     * @memberof CreateCard
     */
    'member_id': number;
    /**
     * 
     * @type {string}
     * @memberof CreateCard
     */
    'card_uid': string;
}
/**
 * 
 * @export
 * @interface Drink
 */
export interface Drink {
    /**
     * 
     * @type {string}
     * @memberof Drink
     */
    'drink': string;
    /**
     * 
     * @type {number}
     * @memberof Drink
     */
    'ml_alc': number;
    /**
     * 
     * @type {number}
     * @memberof Drink
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Drink
     */
    'time': string;
    /**
     * 
     * @type {Member}
     * @memberof Drink
     */
    'consumer': Member;
    /**
     * 
     * @type {Event}
     * @memberof Drink
     */
    'event': Event;
}
/**
 * 
 * @export
 * @interface DrinkCreate
 */
export interface DrinkCreate {
    /**
     * 
     * @type {string}
     * @memberof DrinkCreate
     */
    'drink': string;
    /**
     * 
     * @type {number}
     * @memberof DrinkCreate
     */
    'ml_alc': number;
    /**
     * 
     * @type {string}
     * @memberof DrinkCreate
     */
    'time': string | null;
    /**
     * 
     * @type {number}
     * @memberof DrinkCreate
     */
    'consumer_id': number;
    /**
     * 
     * @type {number}
     * @memberof DrinkCreate
     */
    'event_id': number | null;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'location': string | null;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    'duration'?: number | null;
    /**
     * Minimum role required to view this event
     * @type {Roles}
     * @memberof Event
     */
    'view_role'?: Roles;
    /**
     * Minimum role required to participate in this event
     * @type {Roles}
     * @memberof Event
     */
    'participate_role'?: Roles;
    /**
     * Minimum role required to edit this event
     * @type {Roles}
     * @memberof Event
     */
    'edit_role'?: Roles;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    'id': number;
    /**
     * 
     * @type {Array<Member>}
     * @memberof Event
     */
    'participants': Array<Member>;
    /**
     * 
     * @type {Member}
     * @memberof Event
     */
    'author': Member | null;
}


/**
 * 
 * @export
 * @interface EventCreate
 */
export interface EventCreate {
    /**
     * 
     * @type {string}
     * @memberof EventCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EventCreate
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof EventCreate
     */
    'location': string | null;
    /**
     * 
     * @type {number}
     * @memberof EventCreate
     */
    'duration'?: number | null;
    /**
     * Minimum role required to view this event
     * @type {Roles}
     * @memberof EventCreate
     */
    'view_role'?: Roles;
    /**
     * Minimum role required to participate in this event
     * @type {Roles}
     * @memberof EventCreate
     */
    'participate_role'?: Roles;
    /**
     * Minimum role required to edit this event
     * @type {Roles}
     * @memberof EventCreate
     */
    'edit_role'?: Roles;
}


/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface Member
 */
export interface Member {
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Member
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface Quote
 */
export interface Quote {
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'quote': string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'date': string | null;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'location': string | null;
    /**
     * 
     * @type {number}
     * @memberof Quote
     */
    'id': number;
    /**
     * 
     * @type {Member}
     * @memberof Quote
     */
    'author': Member;
}
/**
 * 
 * @export
 * @interface QuoteCreate
 */
export interface QuoteCreate {
    /**
     * 
     * @type {string}
     * @memberof QuoteCreate
     */
    'quote': string;
    /**
     * 
     * @type {string}
     * @memberof QuoteCreate
     */
    'date': string | null;
    /**
     * 
     * @type {string}
     * @memberof QuoteCreate
     */
    'location': string | null;
    /**
     * 
     * @type {number}
     * @memberof QuoteCreate
     */
    'author_id': number;
}
/**
 * 
 * @export
 * @interface Recipe
 */
export interface Recipe {
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    'time': number | null;
    /**
     * 
     * @type {Situation}
     * @memberof Recipe
     */
    'situation': Situation;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    'id': number;
    /**
     * 
     * @type {Member}
     * @memberof Recipe
     */
    'author': Member | null;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    'image_url': string | null;
}


/**
 * 
 * @export
 * @interface ResponseGetMemberDrinks
 */
export interface ResponseGetMemberDrinks {
}
/**
 * 
 * @export
 * @interface ResponseListEventDrinks
 */
export interface ResponseListEventDrinks {
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Roles = {
    Guest: 'guest',
    MkmMember: 'mkm-member',
    MvgMember: 'mvg-member'
} as const;

export type Roles = typeof Roles[keyof typeof Roles];


/**
 * 
 * @export
 * @enum {string}
 */

export const Situation = {
    Breakfast: 'breakfast',
    Lunch: 'lunch',
    Dinner: 'dinner'
} as const;

export type Situation = typeof Situation[keyof typeof Situation];


/**
 * 
 * @export
 * @interface TokenRefreshRequest
 */
export interface TokenRefreshRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenRefreshRequest
     */
    'refresh_token': string;
}
/**
 * 
 * @export
 * @interface UploadChug
 */
export interface UploadChug {
    /**
     * 
     * @type {Array<string>}
     * @memberof UploadChug
     */
    'id': Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof UploadChug
     */
    'time': Array<number>;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Set Password
         * @param {string} pw 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashPassword: async (pw: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pw' is not null or undefined
            assertParamExists('hashPassword', 'pw', pw)
            const localVarPath = `/auth/hash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pw !== undefined) {
                localVarQueryParameter['pw'] = pw;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Callback
         * @param {string} sessionState 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processOauthCallback: async (sessionState: string, code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionState' is not null or undefined
            assertParamExists('processOauthCallback', 'sessionState', sessionState)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('processOauthCallback', 'code', code)
            const localVarPath = `/auth/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionState !== undefined) {
                localVarQueryParameter['session_state'] = sessionState;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login Redirect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectToLogin: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh Token
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken: async (tokenRefreshRequest: TokenRefreshRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefreshRequest' is not null or undefined
            assertParamExists('refreshAccessToken', 'tokenRefreshRequest', tokenRefreshRequest)
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefreshRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Set Password
         * @param {string} pw 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hashPassword(pw: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hashPassword(pw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.hashPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.logoutUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Callback
         * @param {string} sessionState 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processOauthCallback(sessionState: string, code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processOauthCallback(sessionState, code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.processOauthCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Member>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.readCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login Redirect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redirectToLogin(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redirectToLogin(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.redirectToLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh Token
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshAccessToken(tokenRefreshRequest: TokenRefreshRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAccessToken(tokenRefreshRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refreshAccessToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Set Password
         * @param {string} pw 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashPassword(pw: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.hashPassword(pw, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.logoutUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Callback
         * @param {string} sessionState 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processOauthCallback(sessionState: string, code: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.processOauthCallback(sessionState, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<Member> {
            return localVarFp.readCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login Redirect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectToLogin(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.redirectToLogin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh Token
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken(tokenRefreshRequest: TokenRefreshRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.refreshAccessToken(tokenRefreshRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Set Password
     * @param {string} pw 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public hashPassword(pw: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).hashPassword(pw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logoutUser(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).logoutUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Callback
     * @param {string} sessionState 
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public processOauthCallback(sessionState: string, code: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).processOauthCallback(sessionState, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Users Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public readCurrentUser(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).readCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login Redirect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public redirectToLogin(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).redirectToLogin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh Token
     * @param {TokenRefreshRequest} tokenRefreshRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshAccessToken(tokenRefreshRequest: TokenRefreshRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshAccessToken(tokenRefreshRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CardApi - axios parameter creator
 * @export
 */
export const CardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Card
         * @param {CreateCard} createCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewCard: async (createCard: CreateCard, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCard' is not null or undefined
            assertParamExists('createNewCard', 'createCard', createCard)
            const localVarPath = `/card`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCard, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Card
         * @param {number} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCardByMemberId: async (memberId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('deleteCardByMemberId', 'memberId', memberId)
            const localVarPath = `/card/{member_id}`
                .replace(`{${"member_id"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Cards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCards: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/card`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardApi - functional programming interface
 * @export
 */
export const CardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Card
         * @param {CreateCard} createCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewCard(createCard: CreateCard, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Card>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewCard(createCard, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardApi.createNewCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Card
         * @param {number} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCardByMemberId(memberId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Card>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCardByMemberId(memberId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardApi.deleteCardByMemberId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Cards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCards(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Card>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCards(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardApi.getAllCards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CardApi - factory interface
 * @export
 */
export const CardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CardApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Card
         * @param {CreateCard} createCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewCard(createCard: CreateCard, options?: RawAxiosRequestConfig): AxiosPromise<Card> {
            return localVarFp.createNewCard(createCard, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Card
         * @param {number} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCardByMemberId(memberId: number, options?: RawAxiosRequestConfig): AxiosPromise<Card> {
            return localVarFp.deleteCardByMemberId(memberId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Cards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCards(options?: RawAxiosRequestConfig): AxiosPromise<Array<Card>> {
            return localVarFp.getAllCards(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CardApi - object-oriented interface
 * @export
 * @class CardApi
 * @extends {BaseAPI}
 */
export class CardApi extends BaseAPI {
    /**
     * 
     * @summary Create Card
     * @param {CreateCard} createCard 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardApi
     */
    public createNewCard(createCard: CreateCard, options?: RawAxiosRequestConfig) {
        return CardApiFp(this.configuration).createNewCard(createCard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Card
     * @param {number} memberId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardApi
     */
    public deleteCardByMemberId(memberId: number, options?: RawAxiosRequestConfig) {
        return CardApiFp(this.configuration).deleteCardByMemberId(memberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Cards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardApi
     */
    public getAllCards(options?: RawAxiosRequestConfig) {
        return CardApiFp(this.configuration).getAllCards(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChuggingApi - axios parameter creator
 * @export
 */
export const ChuggingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Event
         * @param {UploadChug} uploadChug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChugs: async (uploadChug: UploadChug, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadChug' is not null or undefined
            assertParamExists('createChugs', 'uploadChug', uploadChug)
            const localVarPath = `/chugs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadChug, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Top Player
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopChuggers: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chugs/top-player`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Events
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChugs: async (skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chugs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChuggingApi - functional programming interface
 * @export
 */
export const ChuggingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChuggingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Event
         * @param {UploadChug} uploadChug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChugs(uploadChug: UploadChug, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChugs(uploadChug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChuggingApi.createChugs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Top Player
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopChuggers(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseChug>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopChuggers(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChuggingApi.getTopChuggers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Events
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChugs(skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseChug>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChugs(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChuggingApi.listChugs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChuggingApi - factory interface
 * @export
 */
export const ChuggingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChuggingApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Event
         * @param {UploadChug} uploadChug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChugs(uploadChug: UploadChug, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.createChugs(uploadChug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Top Player
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopChuggers(limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<BaseChug>> {
            return localVarFp.getTopChuggers(limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Events
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChugs(skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<BaseChug>> {
            return localVarFp.listChugs(skip, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChuggingApi - object-oriented interface
 * @export
 * @class ChuggingApi
 * @extends {BaseAPI}
 */
export class ChuggingApi extends BaseAPI {
    /**
     * 
     * @summary Create Event
     * @param {UploadChug} uploadChug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChuggingApi
     */
    public createChugs(uploadChug: UploadChug, options?: RawAxiosRequestConfig) {
        return ChuggingApiFp(this.configuration).createChugs(uploadChug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Top Player
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChuggingApi
     */
    public getTopChuggers(limit?: number, options?: RawAxiosRequestConfig) {
        return ChuggingApiFp(this.configuration).getTopChuggers(limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Events
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChuggingApi
     */
    public listChugs(skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ChuggingApiFp(this.configuration).listChugs(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DrinksApi - axios parameter creator
 * @export
 */
export const DrinksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Post Drink
         * @param {DrinkCreate} drinkCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDrink: async (drinkCreate: DrinkCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'drinkCreate' is not null or undefined
            assertParamExists('createDrink', 'drinkCreate', drinkCreate)
            const localVarPath = `/drinks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(drinkCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Drinks For Event
         * @param {number} memberId 
         * @param {boolean} [grouped] Group drinks consumed by event_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberDrinks: async (memberId: number, grouped?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('getMemberDrinks', 'memberId', memberId)
            const localVarPath = `/members/{member_id}/drinks`
                .replace(`{${"member_id"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (grouped !== undefined) {
                localVarQueryParameter['grouped'] = grouped;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DrinksApi - functional programming interface
 * @export
 */
export const DrinksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DrinksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Post Drink
         * @param {DrinkCreate} drinkCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDrink(drinkCreate: DrinkCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDrink(drinkCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrinksApi.createDrink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Drinks For Event
         * @param {number} memberId 
         * @param {boolean} [grouped] Group drinks consumed by event_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberDrinks(memberId: number, grouped?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetMemberDrinks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberDrinks(memberId, grouped, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrinksApi.getMemberDrinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DrinksApi - factory interface
 * @export
 */
export const DrinksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DrinksApiFp(configuration)
    return {
        /**
         * 
         * @summary Post Drink
         * @param {DrinkCreate} drinkCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDrink(drinkCreate: DrinkCreate, options?: RawAxiosRequestConfig): AxiosPromise<Drink> {
            return localVarFp.createDrink(drinkCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Drinks For Event
         * @param {number} memberId 
         * @param {boolean} [grouped] Group drinks consumed by event_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberDrinks(memberId: number, grouped?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGetMemberDrinks> {
            return localVarFp.getMemberDrinks(memberId, grouped, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DrinksApi - object-oriented interface
 * @export
 * @class DrinksApi
 * @extends {BaseAPI}
 */
export class DrinksApi extends BaseAPI {
    /**
     * 
     * @summary Post Drink
     * @param {DrinkCreate} drinkCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrinksApi
     */
    public createDrink(drinkCreate: DrinkCreate, options?: RawAxiosRequestConfig) {
        return DrinksApiFp(this.configuration).createDrink(drinkCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Drinks For Event
     * @param {number} memberId 
     * @param {boolean} [grouped] Group drinks consumed by event_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrinksApi
     */
    public getMemberDrinks(memberId: number, grouped?: boolean, options?: RawAxiosRequestConfig) {
        return DrinksApiFp(this.configuration).getMemberDrinks(memberId, grouped, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Participate
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEventParticipant: async (eventId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('addEventParticipant', 'eventId', eventId)
            const localVarPath = `/events/{event_id}/participate`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Event
         * @param {EventCreate} eventCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventCreate: EventCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventCreate' is not null or undefined
            assertParamExists('createEvent', 'eventCreate', eventCreate)
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Event
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEventById', 'id', id)
            const localVarPath = `/events/event/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Calendar Events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendarEvents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/calendar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Event
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEventById', 'id', id)
            const localVarPath = `/events/event/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Drinks For Event
         * @param {number} eventId 
         * @param {boolean} [grouped] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventDrinks: async (eventId: number, grouped?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('listEventDrinks', 'eventId', eventId)
            const localVarPath = `/events/{event_id}/drinks`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (grouped !== undefined) {
                localVarQueryParameter['grouped'] = grouped;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Events
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents: async (skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Events
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUpcomingEvents: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/upcoming`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Participant
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEventParticipant: async (eventId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('removeEventParticipant', 'eventId', eventId)
            const localVarPath = `/events/{event_id}/participate`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Participate
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEventParticipant(eventId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEventParticipant(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.addEventParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Event
         * @param {EventCreate} eventCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventCreate: EventCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Event
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.deleteEventById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Calendar Events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalendarEvents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalendarEvents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.getCalendarEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Event
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.getEventById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Drinks For Event
         * @param {number} eventId 
         * @param {boolean} [grouped] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventDrinks(eventId: number, grouped?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseListEventDrinks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventDrinks(eventId, grouped, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.listEventDrinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Events
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEvents(skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEvents(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.listEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Events
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUpcomingEvents(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUpcomingEvents(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.listUpcomingEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove Participant
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeEventParticipant(eventId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeEventParticipant(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.removeEventParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Participate
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEventParticipant(eventId: number, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.addEventParticipant(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Event
         * @param {EventCreate} eventCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventCreate: EventCreate, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.createEvent(eventCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Event
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.deleteEventById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Calendar Events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendarEvents(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getCalendarEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Event
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.getEventById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Drinks For Event
         * @param {number} eventId 
         * @param {boolean} [grouped] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventDrinks(eventId: number, grouped?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ResponseListEventDrinks> {
            return localVarFp.listEventDrinks(eventId, grouped, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Events
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Event>> {
            return localVarFp.listEvents(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Events
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUpcomingEvents(limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Event>> {
            return localVarFp.listUpcomingEvents(limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Participant
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEventParticipant(eventId: number, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.removeEventParticipant(eventId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * 
     * @summary Participate
     * @param {number} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public addEventParticipant(eventId: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).addEventParticipant(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Event
     * @param {EventCreate} eventCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createEvent(eventCreate: EventCreate, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).createEvent(eventCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Event
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteEventById(id: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).deleteEventById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Calendar Events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getCalendarEvents(options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getCalendarEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Event
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventById(id: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Drinks For Event
     * @param {number} eventId 
     * @param {boolean} [grouped] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public listEventDrinks(eventId: number, grouped?: boolean, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).listEventDrinks(eventId, grouped, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Events
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public listEvents(skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).listEvents(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Events
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public listUpcomingEvents(limit?: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).listUpcomingEvents(limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Participant
     * @param {number} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public removeEventParticipant(eventId: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).removeEventParticipant(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MembersApi - axios parameter creator
 * @export
 */
export const MembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Drinks For Event
         * @param {number} memberId 
         * @param {boolean} [grouped] Group drinks consumed by event_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberDrinks: async (memberId: number, grouped?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('getMemberDrinks', 'memberId', memberId)
            const localVarPath = `/members/{member_id}/drinks`
                .replace(`{${"member_id"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (grouped !== undefined) {
                localVarQueryParameter['grouped'] = grouped;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembersApi - functional programming interface
 * @export
 */
export const MembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Drinks For Event
         * @param {number} memberId 
         * @param {boolean} [grouped] Group drinks consumed by event_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberDrinks(memberId: number, grouped?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetMemberDrinks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberDrinks(memberId, grouped, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.getMemberDrinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMembers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Member>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMembers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.listMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MembersApi - factory interface
 * @export
 */
export const MembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Drinks For Event
         * @param {number} memberId 
         * @param {boolean} [grouped] Group drinks consumed by event_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberDrinks(memberId: number, grouped?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGetMemberDrinks> {
            return localVarFp.getMemberDrinks(memberId, grouped, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers(options?: RawAxiosRequestConfig): AxiosPromise<Array<Member>> {
            return localVarFp.listMembers(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembersApi - object-oriented interface
 * @export
 * @class MembersApi
 * @extends {BaseAPI}
 */
export class MembersApi extends BaseAPI {
    /**
     * 
     * @summary Get Drinks For Event
     * @param {number} memberId 
     * @param {boolean} [grouped] Group drinks consumed by event_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public getMemberDrinks(memberId: number, grouped?: boolean, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).getMemberDrinks(memberId, grouped, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public listMembers(options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).listMembers(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MvgApi - axios parameter creator
 * @export
 */
export const MvgApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Participate
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEventParticipant: async (eventId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('addEventParticipant', 'eventId', eventId)
            const localVarPath = `/events/{event_id}/participate`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Event
         * @param {UploadChug} uploadChug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChugs: async (uploadChug: UploadChug, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadChug' is not null or undefined
            assertParamExists('createChugs', 'uploadChug', uploadChug)
            const localVarPath = `/chugs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadChug, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Drink
         * @param {DrinkCreate} drinkCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDrink: async (drinkCreate: DrinkCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'drinkCreate' is not null or undefined
            assertParamExists('createDrink', 'drinkCreate', drinkCreate)
            const localVarPath = `/drinks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(drinkCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Event
         * @param {EventCreate} eventCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventCreate: EventCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventCreate' is not null or undefined
            assertParamExists('createEvent', 'eventCreate', eventCreate)
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Card
         * @param {CreateCard} createCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewCard: async (createCard: CreateCard, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCard' is not null or undefined
            assertParamExists('createNewCard', 'createCard', createCard)
            const localVarPath = `/card`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCard, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Quote
         * @param {QuoteCreate} quoteCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuote: async (quoteCreate: QuoteCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quoteCreate' is not null or undefined
            assertParamExists('createQuote', 'quoteCreate', quoteCreate)
            const localVarPath = `/quotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(quoteCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Recipe
         * @param {string} name 
         * @param {Situation} situation 
         * @param {string} description 
         * @param {number} time 
         * @param {File | null} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipe: async (name: string, situation: Situation, description: string, time: number, image?: File | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createRecipe', 'name', name)
            // verify required parameter 'situation' is not null or undefined
            assertParamExists('createRecipe', 'situation', situation)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('createRecipe', 'description', description)
            // verify required parameter 'time' is not null or undefined
            assertParamExists('createRecipe', 'time', time)
            const localVarPath = `/recipes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (situation !== undefined) {
                localVarQueryParameter['situation'] = situation;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Card
         * @param {number} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCardByMemberId: async (memberId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('deleteCardByMemberId', 'memberId', memberId)
            const localVarPath = `/card/{member_id}`
                .replace(`{${"member_id"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Event
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEventById', 'id', id)
            const localVarPath = `/events/event/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Recipe
         * @param {number} [recipeId] 
         * @param {string} [recipeName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecipe: async (recipeId?: number, recipeName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/recipes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (recipeId !== undefined) {
                localVarQueryParameter['recipe_id'] = recipeId;
            }

            if (recipeName !== undefined) {
                localVarQueryParameter['recipe_name'] = recipeName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Cards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCards: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/card`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Recipes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRecipes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/recipes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Calendar Events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendarEvents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/calendar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Event
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEventById', 'id', id)
            const localVarPath = `/events/event/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Drinks For Event
         * @param {number} memberId 
         * @param {boolean} [grouped] Group drinks consumed by event_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberDrinks: async (memberId: number, grouped?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('getMemberDrinks', 'memberId', memberId)
            const localVarPath = `/members/{member_id}/drinks`
                .replace(`{${"member_id"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (grouped !== undefined) {
                localVarQueryParameter['grouped'] = grouped;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Quote Of The Day
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomQuote: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/quotes/random_quote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Recipe
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipeById: async (recipeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeId' is not null or undefined
            assertParamExists('getRecipeById', 'recipeId', recipeId)
            const localVarPath = `/recipes/{recipe_id}`
                .replace(`{${"recipe_id"}}`, encodeURIComponent(String(recipeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Top Player
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopChuggers: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chugs/top-player`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Password
         * @param {string} pw 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashPassword: async (pw: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pw' is not null or undefined
            assertParamExists('hashPassword', 'pw', pw)
            const localVarPath = `/auth/hash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pw !== undefined) {
                localVarQueryParameter['pw'] = pw;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Events
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChugs: async (skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chugs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Drinks For Event
         * @param {number} eventId 
         * @param {boolean} [grouped] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventDrinks: async (eventId: number, grouped?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('listEventDrinks', 'eventId', eventId)
            const localVarPath = `/events/{event_id}/drinks`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (grouped !== undefined) {
                localVarQueryParameter['grouped'] = grouped;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Events
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents: async (skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Quotes
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQuotes: async (skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/quotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Events
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUpcomingEvents: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/upcoming`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Callback
         * @param {string} sessionState 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processOauthCallback: async (sessionState: string, code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionState' is not null or undefined
            assertParamExists('processOauthCallback', 'sessionState', sessionState)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('processOauthCallback', 'code', code)
            const localVarPath = `/auth/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionState !== undefined) {
                localVarQueryParameter['session_state'] = sessionState;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login Redirect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectToLogin: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh Token
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken: async (tokenRefreshRequest: TokenRefreshRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefreshRequest' is not null or undefined
            assertParamExists('refreshAccessToken', 'tokenRefreshRequest', tokenRefreshRequest)
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefreshRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Participant
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEventParticipant: async (eventId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('removeEventParticipant', 'eventId', eventId)
            const localVarPath = `/events/{event_id}/participate`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Recipe Image
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRecipeImage: async (image: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'image' is not null or undefined
            assertParamExists('uploadRecipeImage', 'image', image)
            const localVarPath = `/recipes/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MvgApi - functional programming interface
 * @export
 */
export const MvgApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MvgApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Participate
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEventParticipant(eventId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEventParticipant(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.addEventParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Event
         * @param {UploadChug} uploadChug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChugs(uploadChug: UploadChug, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChugs(uploadChug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.createChugs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Post Drink
         * @param {DrinkCreate} drinkCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDrink(drinkCreate: DrinkCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDrink(drinkCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.createDrink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Event
         * @param {EventCreate} eventCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventCreate: EventCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Card
         * @param {CreateCard} createCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewCard(createCard: CreateCard, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Card>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewCard(createCard, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.createNewCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Quote
         * @param {QuoteCreate} quoteCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuote(quoteCreate: QuoteCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuote(quoteCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.createQuote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Recipe
         * @param {string} name 
         * @param {Situation} situation 
         * @param {string} description 
         * @param {number} time 
         * @param {File | null} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecipe(name: string, situation: Situation, description: string, time: number, image?: File | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecipe(name, situation, description, time, image, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.createRecipe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Card
         * @param {number} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCardByMemberId(memberId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Card>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCardByMemberId(memberId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.deleteCardByMemberId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Event
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.deleteEventById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Recipe
         * @param {number} [recipeId] 
         * @param {string} [recipeName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecipe(recipeId?: number, recipeName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecipe(recipeId, recipeName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.deleteRecipe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Cards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCards(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Card>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCards(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.getAllCards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Recipes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRecipes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Recipe>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRecipes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.getAllRecipes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Calendar Events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalendarEvents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalendarEvents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.getCalendarEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Event
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.getEventById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Drinks For Event
         * @param {number} memberId 
         * @param {boolean} [grouped] Group drinks consumed by event_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberDrinks(memberId: number, grouped?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetMemberDrinks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberDrinks(memberId, grouped, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.getMemberDrinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Quote Of The Day
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRandomQuote(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRandomQuote(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.getRandomQuote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Recipe
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecipeById(recipeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecipeById(recipeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.getRecipeById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Top Player
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopChuggers(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseChug>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopChuggers(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.getTopChuggers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set Password
         * @param {string} pw 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hashPassword(pw: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hashPassword(pw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.hashPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Events
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChugs(skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseChug>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChugs(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.listChugs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Drinks For Event
         * @param {number} eventId 
         * @param {boolean} [grouped] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventDrinks(eventId: number, grouped?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseListEventDrinks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventDrinks(eventId, grouped, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.listEventDrinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Events
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEvents(skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEvents(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.listEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMembers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Member>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMembers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.listMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Quotes
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listQuotes(skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quote>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listQuotes(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.listQuotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Events
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUpcomingEvents(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUpcomingEvents(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.listUpcomingEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.logoutUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Callback
         * @param {string} sessionState 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processOauthCallback(sessionState: string, code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processOauthCallback(sessionState, code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.processOauthCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Member>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.readCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login Redirect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redirectToLogin(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redirectToLogin(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.redirectToLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh Token
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshAccessToken(tokenRefreshRequest: TokenRefreshRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAccessToken(tokenRefreshRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.refreshAccessToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove Participant
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeEventParticipant(eventId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeEventParticipant(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.removeEventParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload Recipe Image
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadRecipeImage(image: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadRecipeImage(image, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MvgApi.uploadRecipeImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MvgApi - factory interface
 * @export
 */
export const MvgApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MvgApiFp(configuration)
    return {
        /**
         * 
         * @summary Participate
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEventParticipant(eventId: number, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.addEventParticipant(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Event
         * @param {UploadChug} uploadChug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChugs(uploadChug: UploadChug, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.createChugs(uploadChug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Drink
         * @param {DrinkCreate} drinkCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDrink(drinkCreate: DrinkCreate, options?: RawAxiosRequestConfig): AxiosPromise<Drink> {
            return localVarFp.createDrink(drinkCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Event
         * @param {EventCreate} eventCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventCreate: EventCreate, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.createEvent(eventCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Card
         * @param {CreateCard} createCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewCard(createCard: CreateCard, options?: RawAxiosRequestConfig): AxiosPromise<Card> {
            return localVarFp.createNewCard(createCard, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Quote
         * @param {QuoteCreate} quoteCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuote(quoteCreate: QuoteCreate, options?: RawAxiosRequestConfig): AxiosPromise<Quote> {
            return localVarFp.createQuote(quoteCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Recipe
         * @param {string} name 
         * @param {Situation} situation 
         * @param {string} description 
         * @param {number} time 
         * @param {File | null} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipe(name: string, situation: Situation, description: string, time: number, image?: File | null, options?: RawAxiosRequestConfig): AxiosPromise<Recipe> {
            return localVarFp.createRecipe(name, situation, description, time, image, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Card
         * @param {number} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCardByMemberId(memberId: number, options?: RawAxiosRequestConfig): AxiosPromise<Card> {
            return localVarFp.deleteCardByMemberId(memberId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Event
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.deleteEventById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Recipe
         * @param {number} [recipeId] 
         * @param {string} [recipeName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecipe(recipeId?: number, recipeName?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteRecipe(recipeId, recipeName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Cards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCards(options?: RawAxiosRequestConfig): AxiosPromise<Array<Card>> {
            return localVarFp.getAllCards(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Recipes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRecipes(options?: RawAxiosRequestConfig): AxiosPromise<Array<Recipe>> {
            return localVarFp.getAllRecipes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Calendar Events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendarEvents(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getCalendarEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Event
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.getEventById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Drinks For Event
         * @param {number} memberId 
         * @param {boolean} [grouped] Group drinks consumed by event_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberDrinks(memberId: number, grouped?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGetMemberDrinks> {
            return localVarFp.getMemberDrinks(memberId, grouped, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Quote Of The Day
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomQuote(options?: RawAxiosRequestConfig): AxiosPromise<Quote> {
            return localVarFp.getRandomQuote(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Recipe
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipeById(recipeId: number, options?: RawAxiosRequestConfig): AxiosPromise<Recipe> {
            return localVarFp.getRecipeById(recipeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Top Player
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopChuggers(limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<BaseChug>> {
            return localVarFp.getTopChuggers(limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Password
         * @param {string} pw 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashPassword(pw: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.hashPassword(pw, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Events
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChugs(skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<BaseChug>> {
            return localVarFp.listChugs(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Drinks For Event
         * @param {number} eventId 
         * @param {boolean} [grouped] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventDrinks(eventId: number, grouped?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ResponseListEventDrinks> {
            return localVarFp.listEventDrinks(eventId, grouped, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Events
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Event>> {
            return localVarFp.listEvents(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers(options?: RawAxiosRequestConfig): AxiosPromise<Array<Member>> {
            return localVarFp.listMembers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Quotes
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQuotes(skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quote>> {
            return localVarFp.listQuotes(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Events
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUpcomingEvents(limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Event>> {
            return localVarFp.listUpcomingEvents(limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.logoutUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Callback
         * @param {string} sessionState 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processOauthCallback(sessionState: string, code: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.processOauthCallback(sessionState, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<Member> {
            return localVarFp.readCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login Redirect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectToLogin(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.redirectToLogin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh Token
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken(tokenRefreshRequest: TokenRefreshRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.refreshAccessToken(tokenRefreshRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Participant
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEventParticipant(eventId: number, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.removeEventParticipant(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Recipe Image
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRecipeImage(image: File, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.uploadRecipeImage(image, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MvgApi - object-oriented interface
 * @export
 * @class MvgApi
 * @extends {BaseAPI}
 */
export class MvgApi extends BaseAPI {
    /**
     * 
     * @summary Participate
     * @param {number} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public addEventParticipant(eventId: number, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).addEventParticipant(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Event
     * @param {UploadChug} uploadChug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public createChugs(uploadChug: UploadChug, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).createChugs(uploadChug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Drink
     * @param {DrinkCreate} drinkCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public createDrink(drinkCreate: DrinkCreate, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).createDrink(drinkCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Event
     * @param {EventCreate} eventCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public createEvent(eventCreate: EventCreate, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).createEvent(eventCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Card
     * @param {CreateCard} createCard 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public createNewCard(createCard: CreateCard, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).createNewCard(createCard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Quote
     * @param {QuoteCreate} quoteCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public createQuote(quoteCreate: QuoteCreate, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).createQuote(quoteCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Recipe
     * @param {string} name 
     * @param {Situation} situation 
     * @param {string} description 
     * @param {number} time 
     * @param {File | null} [image] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public createRecipe(name: string, situation: Situation, description: string, time: number, image?: File | null, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).createRecipe(name, situation, description, time, image, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Card
     * @param {number} memberId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public deleteCardByMemberId(memberId: number, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).deleteCardByMemberId(memberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Event
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public deleteEventById(id: number, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).deleteEventById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Recipe
     * @param {number} [recipeId] 
     * @param {string} [recipeName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public deleteRecipe(recipeId?: number, recipeName?: string, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).deleteRecipe(recipeId, recipeName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Cards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public getAllCards(options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).getAllCards(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Recipes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public getAllRecipes(options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).getAllRecipes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Calendar Events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public getCalendarEvents(options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).getCalendarEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Event
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public getEventById(id: number, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).getEventById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Drinks For Event
     * @param {number} memberId 
     * @param {boolean} [grouped] Group drinks consumed by event_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public getMemberDrinks(memberId: number, grouped?: boolean, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).getMemberDrinks(memberId, grouped, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Quote Of The Day
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public getRandomQuote(options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).getRandomQuote(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Recipe
     * @param {number} recipeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public getRecipeById(recipeId: number, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).getRecipeById(recipeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Top Player
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public getTopChuggers(limit?: number, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).getTopChuggers(limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Password
     * @param {string} pw 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public hashPassword(pw: string, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).hashPassword(pw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Events
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public listChugs(skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).listChugs(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Drinks For Event
     * @param {number} eventId 
     * @param {boolean} [grouped] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public listEventDrinks(eventId: number, grouped?: boolean, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).listEventDrinks(eventId, grouped, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Events
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public listEvents(skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).listEvents(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public listMembers(options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).listMembers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Quotes
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public listQuotes(skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).listQuotes(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Events
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public listUpcomingEvents(limit?: number, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).listUpcomingEvents(limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public logoutUser(options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).logoutUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Callback
     * @param {string} sessionState 
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public processOauthCallback(sessionState: string, code: string, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).processOauthCallback(sessionState, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Users Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public readCurrentUser(options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).readCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login Redirect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public redirectToLogin(options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).redirectToLogin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh Token
     * @param {TokenRefreshRequest} tokenRefreshRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public refreshAccessToken(tokenRefreshRequest: TokenRefreshRequest, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).refreshAccessToken(tokenRefreshRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Participant
     * @param {number} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public removeEventParticipant(eventId: number, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).removeEventParticipant(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Recipe Image
     * @param {File} image 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MvgApi
     */
    public uploadRecipeImage(image: File, options?: RawAxiosRequestConfig) {
        return MvgApiFp(this.configuration).uploadRecipeImage(image, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QuotesApi - axios parameter creator
 * @export
 */
export const QuotesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Quote
         * @param {QuoteCreate} quoteCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuote: async (quoteCreate: QuoteCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quoteCreate' is not null or undefined
            assertParamExists('createQuote', 'quoteCreate', quoteCreate)
            const localVarPath = `/quotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(quoteCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Quote Of The Day
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomQuote: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/quotes/random_quote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Quotes
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQuotes: async (skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/quotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuotesApi - functional programming interface
 * @export
 */
export const QuotesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuotesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Quote
         * @param {QuoteCreate} quoteCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuote(quoteCreate: QuoteCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuote(quoteCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuotesApi.createQuote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Quote Of The Day
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRandomQuote(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRandomQuote(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuotesApi.getRandomQuote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Quotes
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listQuotes(skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quote>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listQuotes(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuotesApi.listQuotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QuotesApi - factory interface
 * @export
 */
export const QuotesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuotesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Quote
         * @param {QuoteCreate} quoteCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuote(quoteCreate: QuoteCreate, options?: RawAxiosRequestConfig): AxiosPromise<Quote> {
            return localVarFp.createQuote(quoteCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Quote Of The Day
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomQuote(options?: RawAxiosRequestConfig): AxiosPromise<Quote> {
            return localVarFp.getRandomQuote(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Quotes
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQuotes(skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Quote>> {
            return localVarFp.listQuotes(skip, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuotesApi - object-oriented interface
 * @export
 * @class QuotesApi
 * @extends {BaseAPI}
 */
export class QuotesApi extends BaseAPI {
    /**
     * 
     * @summary Create Quote
     * @param {QuoteCreate} quoteCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotesApi
     */
    public createQuote(quoteCreate: QuoteCreate, options?: RawAxiosRequestConfig) {
        return QuotesApiFp(this.configuration).createQuote(quoteCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Quote Of The Day
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotesApi
     */
    public getRandomQuote(options?: RawAxiosRequestConfig) {
        return QuotesApiFp(this.configuration).getRandomQuote(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Quotes
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotesApi
     */
    public listQuotes(skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return QuotesApiFp(this.configuration).listQuotes(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RecipesApi - axios parameter creator
 * @export
 */
export const RecipesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Recipe
         * @param {string} name 
         * @param {Situation} situation 
         * @param {string} description 
         * @param {number} time 
         * @param {File | null} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipe: async (name: string, situation: Situation, description: string, time: number, image?: File | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createRecipe', 'name', name)
            // verify required parameter 'situation' is not null or undefined
            assertParamExists('createRecipe', 'situation', situation)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('createRecipe', 'description', description)
            // verify required parameter 'time' is not null or undefined
            assertParamExists('createRecipe', 'time', time)
            const localVarPath = `/recipes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (situation !== undefined) {
                localVarQueryParameter['situation'] = situation;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Recipe
         * @param {number} [recipeId] 
         * @param {string} [recipeName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecipe: async (recipeId?: number, recipeName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/recipes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (recipeId !== undefined) {
                localVarQueryParameter['recipe_id'] = recipeId;
            }

            if (recipeName !== undefined) {
                localVarQueryParameter['recipe_name'] = recipeName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Recipes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRecipes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/recipes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Recipe
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipeById: async (recipeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeId' is not null or undefined
            assertParamExists('getRecipeById', 'recipeId', recipeId)
            const localVarPath = `/recipes/{recipe_id}`
                .replace(`{${"recipe_id"}}`, encodeURIComponent(String(recipeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Recipe Image
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRecipeImage: async (image: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'image' is not null or undefined
            assertParamExists('uploadRecipeImage', 'image', image)
            const localVarPath = `/recipes/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecipesApi - functional programming interface
 * @export
 */
export const RecipesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecipesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Recipe
         * @param {string} name 
         * @param {Situation} situation 
         * @param {string} description 
         * @param {number} time 
         * @param {File | null} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecipe(name: string, situation: Situation, description: string, time: number, image?: File | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecipe(name, situation, description, time, image, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipesApi.createRecipe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Recipe
         * @param {number} [recipeId] 
         * @param {string} [recipeName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecipe(recipeId?: number, recipeName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecipe(recipeId, recipeName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipesApi.deleteRecipe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Recipes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRecipes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Recipe>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRecipes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipesApi.getAllRecipes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Recipe
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecipeById(recipeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecipeById(recipeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipesApi.getRecipeById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload Recipe Image
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadRecipeImage(image: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadRecipeImage(image, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipesApi.uploadRecipeImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RecipesApi - factory interface
 * @export
 */
export const RecipesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecipesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Recipe
         * @param {string} name 
         * @param {Situation} situation 
         * @param {string} description 
         * @param {number} time 
         * @param {File | null} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipe(name: string, situation: Situation, description: string, time: number, image?: File | null, options?: RawAxiosRequestConfig): AxiosPromise<Recipe> {
            return localVarFp.createRecipe(name, situation, description, time, image, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Recipe
         * @param {number} [recipeId] 
         * @param {string} [recipeName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecipe(recipeId?: number, recipeName?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteRecipe(recipeId, recipeName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Recipes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRecipes(options?: RawAxiosRequestConfig): AxiosPromise<Array<Recipe>> {
            return localVarFp.getAllRecipes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Recipe
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipeById(recipeId: number, options?: RawAxiosRequestConfig): AxiosPromise<Recipe> {
            return localVarFp.getRecipeById(recipeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Recipe Image
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRecipeImage(image: File, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.uploadRecipeImage(image, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecipesApi - object-oriented interface
 * @export
 * @class RecipesApi
 * @extends {BaseAPI}
 */
export class RecipesApi extends BaseAPI {
    /**
     * 
     * @summary Create Recipe
     * @param {string} name 
     * @param {Situation} situation 
     * @param {string} description 
     * @param {number} time 
     * @param {File | null} [image] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public createRecipe(name: string, situation: Situation, description: string, time: number, image?: File | null, options?: RawAxiosRequestConfig) {
        return RecipesApiFp(this.configuration).createRecipe(name, situation, description, time, image, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Recipe
     * @param {number} [recipeId] 
     * @param {string} [recipeName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public deleteRecipe(recipeId?: number, recipeName?: string, options?: RawAxiosRequestConfig) {
        return RecipesApiFp(this.configuration).deleteRecipe(recipeId, recipeName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Recipes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public getAllRecipes(options?: RawAxiosRequestConfig) {
        return RecipesApiFp(this.configuration).getAllRecipes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Recipe
     * @param {number} recipeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public getRecipeById(recipeId: number, options?: RawAxiosRequestConfig) {
        return RecipesApiFp(this.configuration).getRecipeById(recipeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Recipe Image
     * @param {File} image 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public uploadRecipeImage(image: File, options?: RawAxiosRequestConfig) {
        return RecipesApiFp(this.configuration).uploadRecipeImage(image, options).then((request) => request(this.axios, this.basePath));
    }
}



